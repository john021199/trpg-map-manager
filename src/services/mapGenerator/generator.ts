import type { Location, Connection, GenerationParams } from '../../types';
import {
  getLocationsByType,
  createLocation,
  deleteLocationsByType,
  deleteLocation,
  updateLocation,
} from '../database/locations';
import {
  getAllConnections,
  createConnection,
  deleteConnection,
  connectionExists,
} from '../database/connections';

/**
 * Generate random position for a node
 */
function getRandomPosition(existingLocations: Location[]): { x: number; y: number } {
  const minDistance = 180; // Increased for better spacing
  const maxAttempts = 150;
  const bounds = { minX: 100, maxX: 1400, minY: 100, maxY: 900 }; // Expanded bounds

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const x = Math.random() * (bounds.maxX - bounds.minX) + bounds.minX;
    const y = Math.random() * (bounds.maxY - bounds.minY) + bounds.minY;

    // Check if position is far enough from existing locations
    const isFarEnough = existingLocations.every((loc) => {
      const dx = loc.x - x;
      const dy = loc.y - y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance >= minDistance;
    });

    if (isFarEnough) {
      return { x, y };
    }
  }

  // If we couldn't find a good position, return a random one anyway
  return {
    x: Math.random() * (bounds.maxX - bounds.minX) + bounds.minX,
    y: Math.random() * (bounds.maxY - bounds.minY) + bounds.minY,
  };
}

/**
 * Check if two line segments intersect
 */
function doLinesIntersect(
  p1: { x: number; y: number },
  p2: { x: number; y: number },
  p3: { x: number; y: number },
  p4: { x: number; y: number }
): boolean {
  // Check if segments share an endpoint
  if (
    (p1.x === p3.x && p1.y === p3.y) ||
    (p1.x === p4.x && p1.y === p4.y) ||
    (p2.x === p3.x && p2.y === p3.y) ||
    (p2.x === p4.x && p2.y === p4.y)
  ) {
    return false; // Sharing endpoint is allowed
  }

  const ccw = (a: { x: number; y: number }, b: { x: number; y: number }, c: { x: number; y: number }) => {
    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
  };

  return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
}

/**
 * Reposition only outer locations randomly while maintaining minimum distance
 * Core locations keep their original positions
 */
function repositionLocations(coreLocations: Location[], outerLocations: Location[]): void {
  // Start with core locations as fixed positions
  const positioned: Location[] = [...coreLocations];

  // Only reposition outer locations
  outerLocations.forEach((location) => {
    const newPos = getRandomPosition(positioned);
    updateLocation(location.id, { x: newPos.x, y: newPos.y });
    // Update the location object for next iterations
    location.x = newPos.x;
    location.y = newPos.y;
    positioned.push(location);
  });
}

/**
 * Generate outer nodes
 */
function generateOuterNodes(count: number, existingLocations: Location[]): Location[] {
  const outerNodes: Location[] = [];

  for (let i = 0; i < count; i++) {
    const position = getRandomPosition([...existingLocations, ...outerNodes]);
    const location = createLocation(
      `Outer-${i + 1}`,
      'outer',
      position.x,
      position.y,
      'Auto-generated outer location',
      { autoGenerated: true } // Mark as auto-generated
    );
    outerNodes.push(location);
  }

  return outerNodes;
}

/**
 * Generate connections between nodes
 */
function generateConnections(
  locations: Location[],
  avgDegree: number,
  allowMultipleEdges: boolean,
  allowCycles: boolean
): Connection[] {
  const connections: Connection[] = [];
  const n = locations.length;

  if (n < 2) return connections;

  // Calculate target number of edges based on average degree
  // For undirected graph: E = (n * avgDegree) / 2
  const targetEdges = Math.floor((n * avgDegree) / 2);

  // First, ensure the graph is connected using a random spanning tree
  const unconnected = [...locations];
  const connected = [unconnected.pop()!];

  while (unconnected.length > 0) {
    const fromNode = connected[Math.floor(Math.random() * connected.length)];
    const toIndex = Math.floor(Math.random() * unconnected.length);
    const toNode = unconnected[toIndex];

    const connection = createConnection(fromNode.id, toNode.id, false, 1.0);
    connections.push(connection);

    connected.push(toNode);
    unconnected.splice(toIndex, 1);
  }

  // Add additional random edges to reach target degree
  let attempts = 0;
  const maxAttempts = targetEdges * 10;

  while (connections.length < targetEdges && attempts < maxAttempts) {
    attempts++;

    const fromNode = locations[Math.floor(Math.random() * locations.length)];
    const toNode = locations[Math.floor(Math.random() * locations.length)];

    // Skip if same node and cycles not allowed
    if (fromNode.id === toNode.id && !allowCycles) continue;

    // Skip if connection already exists and multiple edges not allowed
    if (!allowMultipleEdges && connectionExists(fromNode.id, toNode.id)) continue;

    const connection = createConnection(fromNode.id, toNode.id, false, 1.0);
    connections.push(connection);
  }

  return connections;
}

/**
 * Generate a new map with outer nodes
 */
export function generateMap(params: GenerationParams): {
  locations: Location[];
  connections: Connection[];
} {
  const coreLocations = getLocationsByType('core');

  // Generate outer nodes
  const outerLocations = generateOuterNodes(params.outerNodeCount, coreLocations);

  // All locations
  const allLocations = [...coreLocations, ...outerLocations];

  // Generate connections
  const connections = generateConnections(
    allLocations,
    params.avgDegree,
    params.allowMultipleEdges ?? false,
    params.allowCycles ?? true
  );

  return {
    locations: allLocations,
    connections,
  };
}

/**
 * Reset outer nodes and regenerate
 */
export function regenerateOuterNodes(params: GenerationParams): {
  locations: Location[];
  connections: Connection[];
} {
  // Get all outer locations
  const outerLocations = getLocationsByType('outer');
  const allConnections = getAllConnections();

  // Filter only auto-generated outer locations
  const autoGeneratedOuter = outerLocations.filter(
    (loc) => loc.meta?.autoGenerated === true
  );

  // Delete connections involving auto-generated outer nodes
  allConnections.forEach((conn) => {
    const hasAutoGeneratedNode = autoGeneratedOuter.some(
      (loc) => loc.id === conn.sourceId || loc.id === conn.targetId
    );
    if (hasAutoGeneratedNode) {
      deleteConnection(conn.id);
    }
  });

  // Delete only auto-generated outer nodes
  autoGeneratedOuter.forEach((loc) => {
    deleteLocation(loc.id);
  });

  // Generate new map
  return generateMap(params);
}

/**
 * Clear all locations and connections (full reset)
 */
export function clearMap(): void {
  const allConnections = getAllConnections();
  allConnections.forEach((conn) => deleteConnection(conn.id));

  deleteLocationsByType('outer');
  deleteLocationsByType('core');
}

/**
 * Generate connections only (without creating new locations)
 * Ensures each core location connects to at least one outer location
 * Repositions all locations randomly and limits connections per node to 1-5
 */
export function generateConnectionsOnly(params: GenerationParams): {
  locations: Location[];
  connections: Connection[];
} {
  const coreLocations = getLocationsByType('core');
  const outerLocations = getLocationsByType('outer');
  const allLocations = [...coreLocations, ...outerLocations];

  if (coreLocations.length === 0 || outerLocations.length === 0) {
    throw new Error('Need at least one core and one outer location to generate connections');
  }

  // Step 0: Reposition only outer locations randomly, keep core locations fixed
  repositionLocations(coreLocations, outerLocations);

  // Delete all existing connections
  const existingConnections = getAllConnections();
  existingConnections.forEach((conn) => deleteConnection(conn.id));

  const newConnections: Connection[] = [];
  const connectionCount: Map<string, number> = new Map();
  const MIN_CONNECTIONS = 1;
  const MAX_CONNECTIONS = 5;

  // Initialize connection count
  allLocations.forEach((loc) => connectionCount.set(loc.id, 0));

  // Helper to check if adding a connection would violate constraints
  const canAddConnection = (fromId: string, toId: string): boolean => {
    const fromCount = connectionCount.get(fromId) || 0;
    const toCount = connectionCount.get(toId) || 0;
    return fromCount < MAX_CONNECTIONS && toCount < MAX_CONNECTIONS;
  };

  // Helper to increment connection count for both nodes
  const incrementCount = (fromId: string, toId: string) => {
    connectionCount.set(fromId, (connectionCount.get(fromId) || 0) + 1);
    connectionCount.set(toId, (connectionCount.get(toId) || 0) + 1);
  };

  // Helper to check if a new connection would intersect with existing ones
  const wouldIntersect = (
    fromLoc: Location,
    toLoc: Location,
    existingConnections: Connection[],
    allLocs: Location[]
  ): boolean => {
    const locMap = new Map(allLocs.map((loc) => [loc.id, loc]));

    for (const conn of existingConnections) {
      const connFrom = locMap.get(conn.sourceId);
      const connTo = locMap.get(conn.targetId);

      if (!connFrom || !connTo) continue;

      // Skip if connections share a node
      if (
        fromLoc.id === conn.sourceId ||
        fromLoc.id === conn.targetId ||
        toLoc.id === conn.sourceId ||
        toLoc.id === conn.targetId
      ) {
        continue;
      }

      if (
        doLinesIntersect(
          { x: fromLoc.x, y: fromLoc.y },
          { x: toLoc.x, y: toLoc.y },
          { x: connFrom.x, y: connFrom.y },
          { x: connTo.x, y: connTo.y }
        )
      ) {
        return true;
      }
    }
    return false;
  };

  // Step 1: Create connections between core locations first
  // This ensures core nodes can connect to each other
  for (let i = 0; i < coreLocations.length; i++) {
    for (let j = i + 1; j < coreLocations.length; j++) {
      const core1 = coreLocations[i];
      const core2 = coreLocations[j];

      // Randomly decide whether to connect these two cores (50% chance)
      if (Math.random() > 0.5 && canAddConnection(core1.id, core2.id)) {
        if (!wouldIntersect(core1, core2, newConnections, allLocations)) {
          const connection = createConnection(core1.id, core2.id, false, 1.0);
          newConnections.push(connection);
          incrementCount(core1.id, core2.id);
        }
      }
    }
  }

  // Step 2: Ensure each core location connects to at least one outer location
  for (const core of coreLocations) {
    const availableOuters = outerLocations.filter(
      (outer) => canAddConnection(core.id, outer.id) && !wouldIntersect(core, outer, newConnections, allLocations)
    );

    if (availableOuters.length > 0) {
      const randomOuter = availableOuters[Math.floor(Math.random() * availableOuters.length)];
      const connection = createConnection(core.id, randomOuter.id, false, 1.0);
      newConnections.push(connection);
      incrementCount(core.id, randomOuter.id);
    }
  }

  // Step 3: Generate additional connections while respecting constraints
  const targetEdges = Math.floor((allLocations.length * params.avgDegree) / 2);
  let attempts = 0;
  const maxAttempts = targetEdges * 20;

  while (newConnections.length < targetEdges && attempts < maxAttempts) {
    attempts++;

    const fromNode = allLocations[Math.floor(Math.random() * allLocations.length)];
    const toNode = allLocations[Math.floor(Math.random() * allLocations.length)];

    // Skip if same node
    if (fromNode.id === toNode.id) continue;

    // Skip if connection already exists
    if (connectionExists(fromNode.id, toNode.id)) continue;

    // Skip if would exceed max connections
    if (!canAddConnection(fromNode.id, toNode.id)) continue;

    // Skip if would intersect with existing connections
    if (wouldIntersect(fromNode, toNode, newConnections, allLocations)) continue;

    const connection = createConnection(fromNode.id, toNode.id, false, 1.0);
    newConnections.push(connection);
    incrementCount(fromNode.id, toNode.id);
  }

  // Step 4: Ensure all nodes have at least MIN_CONNECTIONS
  for (const loc of allLocations) {
    const count = connectionCount.get(loc.id) || 0;
    if (count < MIN_CONNECTIONS) {
      // Try to add a connection
      const candidates = allLocations.filter(
        (other) =>
          other.id !== loc.id &&
          canAddConnection(loc.id, other.id) &&
          !connectionExists(loc.id, other.id) &&
          !wouldIntersect(loc, other, newConnections, allLocations)
      );

      if (candidates.length > 0) {
        const target = candidates[Math.floor(Math.random() * candidates.length)];
        const connection = createConnection(loc.id, target.id, false, 1.0);
        newConnections.push(connection);
        incrementCount(loc.id, target.id);
      }
    }
  }

  return {
    locations: allLocations,
    connections: newConnections,
  };
}

/**
 * Clear all connections only (keep locations)
 */
export function clearConnections(): void {
  const allConnections = getAllConnections();
  allConnections.forEach((conn) => deleteConnection(conn.id));
}

/**
 * Get graph statistics
 */
export function getGraphStats(): {
  totalNodes: number;
  coreNodes: number;
  outerNodes: number;
  totalEdges: number;
  avgDegree: number;
} {
  const coreLocations = getLocationsByType('core');
  const outerLocations = getLocationsByType('outer');
  const connections = getAllConnections();

  const totalNodes = coreLocations.length + outerLocations.length;
  const totalEdges = connections.length;
  const avgDegree = totalNodes > 0 ? (totalEdges * 2) / totalNodes : 0;

  return {
    totalNodes,
    coreNodes: coreLocations.length,
    outerNodes: outerLocations.length,
    totalEdges,
    avgDegree,
  };
}
